/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Motor Control
//
// Rob Dobson 2021-2023
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "MotorControl.h"
#include "Logger.h"

static const char *MODULE_PREFIX = "MotorControl";

#define DEBUG_STEPPER_CMD_JSON

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor / Destructor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MotorControl::MotorControl()
{
}

MotorControl::~MotorControl()
{
    // Tell motion controller to stop
    _motionController.teardown();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Setup
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void MotorControl::setup(RaftJsonIF& config)
{
    // Base setup
    HWElemBase::setup(config);

    // Setup motion controller
    _motionController.setup(config);

    // Debug
    LOG_I(MODULE_PREFIX, "setup name %s type %s bus %s pollRateHz %f",
            _name.c_str(), _type.c_str(), _busName.c_str(), _pollRateHz);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Post-Setup - called after any buses have been connected
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void MotorControl::postSetup()
{
    // If HWElem is configured with a bus then use soft commands for direction reversal
    _motionController.setupSerialBus(getBus(), getBus() != nullptr); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Service
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void MotorControl::service()
{
    // Service motion controller
    _motionController.service();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Has capability
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool MotorControl::hasCapability(const char* pCapabilityStr)
{
    switch(pCapabilityStr[0])
    {
        // Streaming outbound
        case 's': return true;
    }
    return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get Data JSON
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

String MotorControl::getDataJSON(HWElemStatusLevel_t level)
{
    // Get data
    return _motionController.getDataJSON(level);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get a named value
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

double MotorControl::getNamedValue(const char* param, bool& isFresh)
{
    switch(tolower(param[0]))
    {
        case 'x':
        case 'y':
        case 'z':
        {
            // Get axis position
            isFresh = true;
            AxesPosValues pos = _motionController.getLastMonitoredPos();
            switch(tolower(param[0]))
            {
                case 'x': return pos.getVal(0);
                case 'y': return pos.getVal(1);
                case 'z': return pos.getVal(2);
            }
            isFresh = false;
            return 0;
        }
        case 'b':
        {
            // Check for busy
            isFresh = true;
            return _motionController.isBusy();
            break;
        }
        default: { isFresh = false; return 0; }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get values binary = format specific to hardware
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint32_t MotorControl::getValsBinary(uint32_t formatCode, uint8_t* pBuf, uint32_t bufMaxLen)
{
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Send encoded command
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RaftRetCode MotorControl::sendCmdBinary(uint32_t formatCode, const uint8_t* pData, uint32_t dataLen)
{
    // Check format code
    if (formatCode == MULTISTEPPER_CMD_BINARY_FORMAT_1)
    {
        // Check length ok
        if (dataLen < MULTISTEPPER_OPCODE_POS + 1)
            return RAFT_INVALID_DATA;

        // Check op-code
        switch(pData[MULTISTEPPER_OPCODE_POS])
        {
            case MULTISTEPPER_MOVETO_OPCODE:
            {
                handleCmdBinary_MoveTo(pData + MULTISTEPPER_OPCODE_POS + 1, dataLen - MULTISTEPPER_OPCODE_POS - 1);
                break;
            }
        }
    }
    return RAFT_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Handle JSON command
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

RaftRetCode MotorControl::sendCmdJSON(const char* cmdJSON)
{
    // Extract command from JSON
    RaftJson jsonInfo(cmdJSON);
    String cmd = jsonInfo.getString("cmd", "");
    if (cmd.equalsIgnoreCase("motion"))
    {
        MotionArgs motionArgs;
        motionArgs.fromJSON(cmdJSON);
#ifdef DEBUG_STEPPER_CMD_JSON
        String cmdStr = motionArgs.toJSON();
        LOG_I(MODULE_PREFIX, "sendCmdJSON %s", cmdStr.c_str());
#endif
        _motionController.moveTo(motionArgs);
    }
    return RAFT_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Handle MoveTo
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void MotorControl::handleCmdBinary_MoveTo(const uint8_t* pData, uint32_t dataLen)
{
    // Check length ok
    if (dataLen < MULTISTEPPER_MOVETO_BINARY_FORMAT_POS + 1)
        return;
    
    // Check version of args
    if (pData[MULTISTEPPER_MOVETO_BINARY_FORMAT_POS] != MULTISTEPPER_MOTION_ARGS_BINARY_FORMAT_1)
        return;

    // Check args length
    if (dataLen < sizeof(MotionArgs))
        return;

    // Send the request for interpretation
    _motionController.moveTo((const MotionArgs&)*pData);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get debug str
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

String MotorControl::getDebugStr()
{
    return _motionController.getDebugStr();
}
